# 4.4 子程序与功能块

> 本节将介绍PLC的模块化编程方法

## 学习目标

- 掌握子程序的创建和调用
- 理解功能块的概念
- 能够实现模块化编程

---

## 1. 模块化编程概述

### 1.1 什么是模块化编程

模块化编程是将程序分解为多个独立的功能模块，每个模块完成特定功能，通过调用和参数传递协同工作。

```
模块化编程结构：

┌─────────────────────────────────────────────────────┐
│                    主程序 (OB1/Main)                │
├─────────────────────────────────────────────────────┤
│                                                     │
│    ┌─────────┐   ┌─────────┐   ┌─────────┐        │
│    │电机控制 │   │温度控制 │   │报警处理 │        │
│    │   FB1   │   │   FB2   │   │   FC1   │        │
│    └─────────┘   └─────────┘   └─────────┘        │
│         │             │             │              │
│         ▼             ▼             ▼              │
│    ┌─────────┐   ┌─────────┐   ┌─────────┐        │
│    │ 电机1   │   │ 加热器  │   │ 声光报警 │        │
│    │ DB1     │   │ DB2     │   │  (无DB) │        │
│    └─────────┘   └─────────┘   └─────────┘        │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 1.2 模块化编程优点

| 优点 | 说明 |
|------|------|
| **复用性** | 相同功能只需编写一次 |
| **可维护性** | 修改局部不影响整体 |
| **可读性** | 程序结构清晰 |
| **团队协作** | 可分工并行开发 |
| **调试方便** | 可单独测试各模块 |

### 1.3 程序块类型

```
西门子程序块类型：

┌────────────────────────────────────────────────────┐
│  块类型   │  说明              │  特点             │
├────────────────────────────────────────────────────┤
│  OB       │  组织块            │  系统调用入口     │
│  FB       │  功能块            │  有背景DB，有状态 │
│  FC       │  功能              │  无背景DB，无状态 │
│  DB       │  数据块            │  存储数据         │
│  SFB/SFC  │  系统功能块/功能   │  系统内置         │
└────────────────────────────────────────────────────┘

三菱程序结构：
· 主程序：主扫描程序
· 子程序：P0-P127
· 中断程序：I0-I127
```

---

## 2. 子程序基础

### 2.1 子程序概念

```
子程序工作流程：

主程序：                    子程序：
┌─────────────┐            ┌─────────────┐
│  ...        │            │  子程序代码 │
├─────────────┤            │             │
│ CALL 子程序 │────────────→  ...        │
├─────────────┤            │             │
│  （暂停）   │            │  RETURN     │
├─────────────┤    ←───────│             │
│  继续执行   │            └─────────────┘
└─────────────┘

特点：
· 被调用时执行
· 执行完返回主程序
· 可被多次调用
· 可带参数
```

### 2.2 三菱子程序

```
【子程序结构】

主程序：
       X0
    ───┤├───────[CALL P10]───   // 调用子程序P10

       X1
    ───┤├───────[CALL P20]───   // 调用子程序P20

               [FEND]───        // 主程序结束

【P10】子程序P10
       X10
    ───┤├───────( Y0 )───

               [SRET]───        // 子程序返回

【P20】子程序P20
       X20
    ───┤├───────( Y1 )───

               [SRET]───        // 子程序返回

               [END]───         // 程序结束
```

### 2.3 带参数的子程序

```
三菱带参数子程序调用：

【调用】
       X0
    ───┤├───────[CALL P10 D0 D10 D100]───

· P10：子程序号
· D0：输入参数1
· D10：输入参数2
· D100：输出参数

【子程序定义】
【P10】
       SM400
    ───┤├───────[ADD D0 D10 D100]───  // 两数相加

               [SRET]───

【说明】
参数按顺序对应
D0→第一参数，D10→第二参数，D100→第三参数
```

---

## 3. 西门子功能（FC）

### 3.1 FC基本概念

FC（Function）是没有内部存储的程序块，每次调用独立执行。

```
FC特点：

┌────────────────────────────────────────────────────┐
│  功能（FC）特性                                    │
├────────────────────────────────────────────────────┤
│  · 无背景数据块                                   │
│  · 无内部状态保持                                 │
│  · 每次调用独立                                   │
│  · 适合纯计算、转换                               │
│  · 输入/输出/临时变量                             │
└────────────────────────────────────────────────────┘
```

### 3.2 FC创建与编程

```
FC接口定义：

FUNCTION FC_Add : INT
// 函数名和返回值类型

VAR_INPUT
    Value1 : INT;    // 输入参数1
    Value2 : INT;    // 输入参数2
END_VAR

VAR_OUTPUT
    Result : INT;    // 输出参数
END_VAR

VAR_TEMP
    Temp : INT;      // 临时变量
END_VAR

BEGIN
    // 函数体
    Temp := Value1 + Value2;
    Result := Temp;
    FC_Add := Temp;  // 返回值
END_FUNCTION
```

### 3.3 FC调用

```
【梯形图调用】
              ┌──────────┐
   I0.0 ─────┤  FC_Add  │
              │          │
   MW10 ─────┤Value1    │
   MW12 ─────┤Value2    │
              │          │
              │Result ───├──── MW20
              └──────────┘

【SCL调用】
MW20 := FC_Add(Value1 := MW10, Value2 := MW12);

// 或
FC_Add(Value1 := MW10, 
       Value2 := MW12, 
       Result => MW20);
```

---

## 4. 西门子功能块（FB）

### 4.1 FB基本概念

FB（Function Block）有背景数据块，可以保存内部状态。

```
FB特点：

┌────────────────────────────────────────────────────┐
│  功能块（FB）特性                                  │
├────────────────────────────────────────────────────┤
│  · 有背景数据块（Instance DB）                    │
│  · 内部变量可保持状态                             │
│  · 同一FB可多次实例化                             │
│  · 适合有状态的控制对象                           │
│  · 如：电机控制、阀门控制                         │
└────────────────────────────────────────────────────┘

FB与实例DB关系：
┌─────────┐      ┌─────────┐
│   FB1   │ ←──→ │  DB10   │  实例1
│ 电机控制│      │ 电机1   │
└─────────┘      └─────────┘
     │           ┌─────────┐
     └────────→ │  DB11   │  实例2
                │ 电机2   │
                └─────────┘
```

### 4.2 FB创建与编程

```
FB接口定义：

FUNCTION_BLOCK FB_Motor
// 功能块名称

VAR_INPUT
    Start : BOOL;     // 启动
    Stop : BOOL;      // 停止
END_VAR

VAR_OUTPUT
    Running : BOOL;   // 运行状态
    Fault : BOOL;     // 故障
END_VAR

VAR
    // 静态变量（保存在实例DB中）
    RunCmd : BOOL;    // 运行命令
    FaultLatch : BOOL;  // 故障锁存
END_VAR

VAR_TEMP
    // 临时变量
    Temp : BOOL;
END_VAR

BEGIN
    // 启停控制
    IF Start AND NOT Stop THEN
        RunCmd := TRUE;
    ELSIF Stop THEN
        RunCmd := FALSE;
    END_IF;
    
    // 输出
    Running := RunCmd;
    Fault := FaultLatch;
END_FUNCTION_BLOCK
```

### 4.3 FB调用（实例化）

```
【梯形图调用】
              ┌──────────┐
   I0.0 ─────┤ FB_Motor │──── DB10（实例数据块）
              │          │
   I0.0 ─────┤Start     │
   I0.1 ─────┤Stop      │
              │          │
              │Running ──├──── Q0.0
              │Fault ────├──── Q0.1
              └──────────┘

【SCL调用】
// 声明实例
VAR
    Motor1 : FB_Motor;  // 自动创建实例DB
END_VAR

// 调用
Motor1(Start := I0.0,
       Stop := I0.1,
       Running => Q0.0,
       Fault => Q0.1);

// 访问内部变量
IF Motor1.RunCmd THEN
    // ...
END_IF;
```

### 4.4 多实例

```
同一FB控制多台设备：

VAR
    Motor1 : FB_Motor;  // 电机1实例
    Motor2 : FB_Motor;  // 电机2实例
    Motor3 : FB_Motor;  // 电机3实例
END_VAR

// 电机1
Motor1(Start := I0.0, Stop := I0.1,
       Running => Q0.0, Fault => Q0.1);

// 电机2
Motor2(Start := I0.2, Stop := I0.3,
       Running => Q0.2, Fault => Q0.3);

// 电机3
Motor3(Start := I0.4, Stop := I0.5,
       Running => Q0.4, Fault => Q0.5);

每个实例有独立的状态数据
```

---

## 5. FC与FB的区别

### 5.1 对比表

| 特性 | FC（功能） | FB（功能块） |
|------|-----------|--------------|
| **背景DB** | 无 | 有（实例DB） |
| **状态保持** | 不保持 | 保持 |
| **实例化** | 不需要 | 需要 |
| **内部变量** | 仅临时变量 | 静态+临时 |
| **适用场景** | 纯计算 | 有状态控制 |
| **调用开销** | 小 | 较大 |

### 5.2 选择原则

```
何时使用FC：
· 数学计算
· 数据转换
· 格式处理
· 无需保存状态

何时使用FB：
· 设备控制（电机、阀门）
· 需要保存状态
· 定时器/计数器封装
· 多实例应用
```

---

## 6. 参数传递

### 6.1 参数类型

```
参数类型说明：

┌────────────────────────────────────────────────────┐
│  类型        │  说明                               │
├────────────────────────────────────────────────────┤
│  VAR_INPUT   │  输入参数，只读                     │
│  VAR_OUTPUT  │  输出参数，只写                     │
│  VAR_IN_OUT  │  输入输出，可读可写                 │
│  VAR_TEMP    │  临时变量，不保持                   │
│  VAR         │  静态变量，保持（仅FB）             │
└────────────────────────────────────────────────────┘
```

### 6.2 传值与传址

```
传值（By Value）：
· 复制参数值
· 修改不影响原变量
· 适用于简单数据类型

传址（By Reference）：
· 传递地址
· 修改影响原变量
· 适用于数组、结构体
· VAR_IN_OUT使用传址

示例：
VAR_IN_OUT
    DataArray : ARRAY[0..9] OF INT;  // 传址
END_VAR
```

---

## 7. 应用实例

### 7.1 电机控制功能块

```
完整的电机控制FB：

FUNCTION_BLOCK FB_MotorControl

VAR_INPUT
    Start : BOOL;       // 启动命令
    Stop : BOOL;        // 停止命令
    EmergStop : BOOL;   // 急停
    Feedback : BOOL;    // 运行反馈
    MaxRunTime : TIME := T#1H;  // 最大运行时间
END_VAR

VAR_OUTPUT
    Output : BOOL;      // 输出到接触器
    Running : BOOL;     // 运行指示
    Fault : BOOL;       // 故障指示
    RunTime : TIME;     // 累计运行时间
END_VAR

VAR
    RunCmd : BOOL;              // 运行命令
    StartEdge : BOOL;           // 启动边沿
    FaultLatch : BOOL;          // 故障锁存
    FeedbackTimer : TON;        // 反馈超时定时器
    RunTimeTimer : TON;         // 运行计时
END_VAR

BEGIN
    // 急停优先
    IF EmergStop THEN
        RunCmd := FALSE;
        FaultLatch := TRUE;
    // 正常启停
    ELSIF Start AND NOT Stop AND NOT FaultLatch THEN
        RunCmd := TRUE;
    ELSIF Stop THEN
        RunCmd := FALSE;
    END_IF;
    
    // 反馈检测（启动后3秒内应有反馈）
    FeedbackTimer(IN := RunCmd AND NOT Feedback,
                  PT := T#3S);
    IF FeedbackTimer.Q THEN
        FaultLatch := TRUE;
        RunCmd := FALSE;
    END_IF;
    
    // 运行计时
    RunTimeTimer(IN := Running, PT := MaxRunTime);
    RunTime := RunTimeTimer.ET;
    
    // 输出
    Output := RunCmd;
    Running := Feedback;
    Fault := FaultLatch;
END_FUNCTION_BLOCK
```

### 7.2 温度PID功能块

```
简化的PID功能块：

FUNCTION_BLOCK FB_PID_Simple

VAR_INPUT
    PV : REAL;          // 过程值
    SP : REAL;          // 设定值
    Kp : REAL := 1.0;   // 比例系数
    Ki : REAL := 0.1;   // 积分系数
    Kd : REAL := 0.01;  // 微分系数
END_VAR

VAR_OUTPUT
    CV : REAL;          // 控制输出 (0-100%)
END_VAR

VAR
    Error : REAL;       // 误差
    LastError : REAL;   // 上次误差
    Integral : REAL;    // 积分累计
    Derivative : REAL;  // 微分
END_VAR

BEGIN
    // 计算误差
    Error := SP - PV;
    
    // 积分
    Integral := Integral + Error;
    // 积分限幅
    IF Integral > 1000 THEN Integral := 1000; END_IF;
    IF Integral < -1000 THEN Integral := -1000; END_IF;
    
    // 微分
    Derivative := Error - LastError;
    LastError := Error;
    
    // PID计算
    CV := Kp * Error + Ki * Integral + Kd * Derivative;
    
    // 输出限幅
    IF CV > 100.0 THEN CV := 100.0; END_IF;
    IF CV < 0.0 THEN CV := 0.0; END_IF;
END_FUNCTION_BLOCK
```

### 7.3 通用定时器封装

```
三菱子程序封装延时功能：

【调用】
       X0
    ───┤├───────[CALL P100 M0 K50 M100]───

· M0：启动条件
· K50：延时时间（5秒）
· M100：延时到达输出

【P100】延时子程序
// 输入M0 = 启动条件（D0）
// 输入K50 = 设定时间（D1）
// 输出M100 = 到达标志（D2）

       D0           D1
    ───┤├───────[OUT T200]───

       T200
    ───┤├───────[SET D2]───

       D0
    ───┤/├──────[RST D2]───
               [RST T200]───

               [SRET]───
```

---

## 本节小结

```
子程序与功能块要点：

┌────────────────────────────────────────────────────┐
│  子程序                                            │
│  · 被调用时执行，执行完返回                       │
│  · 可带参数传递                                   │
│  · 三菱：CALL Pn / SRET                           │
├────────────────────────────────────────────────────┤
│  功能（FC）                                        │
│  · 无背景DB，无状态保持                           │
│  · 适合纯计算、数据处理                           │
│  · 每次调用独立                                   │
├────────────────────────────────────────────────────┤
│  功能块（FB）                                      │
│  · 有背景DB，有状态保持                           │
│  · 可多次实例化                                   │
│  · 适合设备控制等有状态场景                       │
├────────────────────────────────────────────────────┤
│  设计原则                                          │
│  · 单一职责：每个模块做一件事                     │
│  · 高内聚低耦合                                   │
│  · 接口清晰，参数明确                             │
└────────────────────────────────────────────────────┘
```

---

## 练习题

1. 说明FC和FB的主要区别。
2. 编写一个三菱子程序实现两数相加。
3. 设计一个电机控制功能块，包含启停和故障检测。
4. 什么场景适合使用FB而不是FC？

---

[← 上一节：4.3 程序控制指令](./4.3.md) | [返回目录](/) | [下一节：4.5 中断程序设计 →](./4.5.md)
