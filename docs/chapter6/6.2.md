# 6.2 串口通信RS232/RS485

> 本节将介绍串口通信的原理和应用

## 学习目标

- 掌握RS232和RS485的特点与区别
- 理解串口通信参数配置方法
- 熟悉Modbus RTU协议结构
- 能够实现PLC的串口通信编程

---

## 一、RS232通信标准

### 1.1 RS232概述

RS232（Recommended Standard 232）是美国电子工业协会（EIA）制定的串行通信接口标准，广泛应用于计算机与外设之间的通信。

**RS232特点**：
- 单端信号传输（相对于地电平）
- 点对点通信（一对一）
- 全双工通信方式
- 传输距离：≤15米
- 传输速率：≤20Kbps
- 电压电平：±3V～±15V

### 1.2 RS232电气特性

```
信号电平定义：
┌────────────────────────────────────┐
│  逻辑1（Mark）  ：-3V ～ -15V      │
│  逻辑0（Space） ：+3V ～ +15V      │
│  无效区        ：-3V ～ +3V        │
└────────────────────────────────────┘

电平波形示意：
       +15V ┤    ┌──┐     ┌──┐
       +3V ┤....│..│.....│..│.... 逻辑0
        0V ┤────┴──┴─┬───┴──┴─┬──
       -3V ┤.........│.........│... 逻辑1
      -15V ┤         └─────────┘
              0   1   0   1   0
```

### 1.3 RS232标准接口

**DB9接口引脚定义**：

| 引脚 | 信号 | 名称 | 方向(DTE) | 功能说明 |
|:----:|:----:|:-----|:---------:|:---------|
| 1 | DCD | 载波检测 | 输入 | 调制解调器检测到载波 |
| 2 | RXD | 接收数据 | 输入 | 接收数据线 |
| 3 | TXD | 发送数据 | 输出 | 发送数据线 |
| 4 | DTR | 数据终端就绪 | 输出 | 终端准备好 |
| 5 | GND | 信号地 | - | 公共参考地 |
| 6 | DSR | 数据设备就绪 | 输入 | 数据设备准备好 |
| 7 | RTS | 请求发送 | 输出 | 请求发送数据 |
| 8 | CTS | 清除发送 | 输入 | 允许发送数据 |
| 9 | RI | 振铃指示 | 输入 | 检测到振铃信号 |

```
DB9接口外形：
    ┌─────────────────┐
    │ 1   2   3   4   5 │
    │   6   7   8   9   │
    └─────────────────┘
      (公头-DTE端)
```

### 1.4 RS232连接方式

**直连线（DCE-DTE连接）**：
```
  DTE(PC)          DCE(设备)
    TXD ─────────── RXD
    RXD ─────────── TXD
    GND ─────────── GND
    RTS ─────────── CTS
    CTS ─────────── RTS
```

**交叉线（DTE-DTE连接）**：
```
  DTE(PC1)         DTE(PC2)
    TXD ──────╲╱── TXD
    RXD ──────╱╲── RXD
    GND ─────────── GND
```

---

## 二、RS485通信标准

### 2.1 RS485概述

RS485是为克服RS232的距离和多点通信限制而设计的工业通信标准，采用差分信号传输，具有更强的抗干扰能力。

**RS485特点**：
- 差分信号传输（平衡传输）
- 支持多点通信（最多32/128/256个节点）
- 半双工或全双工通信
- 传输距离：≤1200米
- 传输速率：≤10Mbps
- 电压电平：±1.5V～±6V（差分）

### 2.2 RS485电气特性

```
差分信号原理：
┌─────────────────────────────────────────┐
│  A线（非反相端，Data+）                   │
│  B线（反相端，Data-）                     │
│                                          │
│  逻辑1：A-B > +200mV                     │
│  逻辑0：A-B < -200mV                     │
└─────────────────────────────────────────┘

差分信号波形：
    A线  ┌──┐  ┌──┐  ┌──────┐
    ─────┘  └──┘  └──┘      └────
    
    B线     ┌──┐  ┌──┐      ┌────
    ────────┘  └──┘  └──────┘
         1   0   1   0   1    0
```

### 2.3 RS485网络拓扑

**总线型拓扑结构**：
```
               主干总线（双绞线）
    ═══════╤═══════╤═══════╤═══════╤═══════
           │       │       │       │
        ┌──┴──┐ ┌──┴──┐ ┌──┴──┐ ┌──┴──┐
        │设备1│ │设备2│ │设备3│ │设备4│
        │#01 │ │#02 │ │#03 │ │#04 │
        └─────┘ └─────┘ └─────┘ └─────┘
    
    [RT]                               [RT]
    终端电阻                           终端电阻
    (120Ω)                            (120Ω)
```

**RS485接线方式**：

| 接线方式 | 线数 | 说明 |
|:--------:|:----:|:-----|
| 两线制 | 2 | A、B（半双工） |
| 四线制 | 4 | TX+、TX-、RX+、RX-（全双工） |

### 2.4 RS485布线规范

```
正确的RS485布线：
┌────────────────────────────────────────────┐
│ 1. 使用屏蔽双绞线                           │
│ 2. 总线两端加120Ω终端电阻                   │
│ 3. 分支线长度≤3米                          │
│ 4. 避免星型连接                            │
│ 5. 屏蔽层单点接地                          │
└────────────────────────────────────────────┘

终端电阻连接：
    A ───┬──────────────────────┬─── A
         │                      │
        [R]                    [R]
        120Ω                   120Ω
         │                      │
    B ───┴──────────────────────┴─── B
```

---

## 三、RS422通信标准

### 3.1 RS422特点

RS422是RS485的前身，采用差分传输，支持全双工通信。

| 特性 | RS422 |
|:-----|:------|
| 传输方式 | 差分平衡 |
| 通信方式 | 全双工 |
| 网络结构 | 一主多从（最多10个） |
| 传输距离 | ≤1200米 |
| 传输速率 | ≤10Mbps |

### 3.2 RS422连接

```
RS422四线制连接：
    主站                    从站
  TX+ ────────────────── RX+
  TX- ────────────────── RX-
  RX+ ────────────────── TX+
  RX- ────────────────── TX-
  GND ────────────────── GND
```

---

## 四、三种标准对比

### 4.1 特性对比表

| 特性 | RS232 | RS422 | RS485 |
|:-----|:------|:------|:------|
| 传输方式 | 单端 | 差分 | 差分 |
| 通信方式 | 全双工 | 全双工 | 半双工/全双工 |
| 最大节点数 | 2 | 10 | 32(标准)/256(扩展) |
| 最大距离 | 15m | 1200m | 1200m |
| 最高速率 | 20Kbps | 10Mbps | 10Mbps |
| 抗干扰能力 | 弱 | 强 | 强 |
| 典型应用 | PC通信 | 工业自动化 | 工业现场总线 |

### 4.2 应用场景选择

```
选择决策树：
                    ┌──────────────┐
                    │ 通信距离>15m? │
                    └──────┬───────┘
                      是 /   \ 否
                       /       \
           ┌──────────┐     ┌──────────┐
           │需要多点？  │     │ RS232    │
           └────┬─────┘     └──────────┘
             是 / \ 否
              /     \
    ┌────────┐     ┌────────┐
    │ RS485  │     │ RS422  │
    └────────┘     └────────┘
```

---

## 五、串口通信参数配置

### 5.1 通信参数

进行串口通信时，必须正确配置以下参数，且通信双方参数必须一致：

| 参数 | 说明 | 常用值 |
|:-----|:-----|:-------|
| 波特率 | 数据传输速率 | 9600, 19200, 38400, 115200 |
| 数据位 | 每帧数据位数 | 7, 8 |
| 停止位 | 帧结束标志 | 1, 1.5, 2 |
| 校验位 | 数据校验方式 | None, Odd, Even |

### 5.2 数据帧格式

```
异步串行通信帧格式：
┌────┬─────────────────────┬────┬────┐
│起始│   数据位(5-8位)      │校验│停止│
│ 位 │ D0 D1 D2 D3 D4 D5 D6 D7│ 位 │ 位 │
└────┴─────────────────────┴────┴────┘
  1位        8位             0/1位 1/2位

示例：发送字符'A'(0x41=01000001)
     ___     _   _       _____
空闲|   |起始| | | | | | | |校|停|空闲
____|   |____|_|_|_|_|_|_|_|验|止|____
        0 1 0 0 0 0 0 1 0
         (LSB优先发送)
```

### 5.3 西门子S7-1200串口配置

**硬件配置**：
```
TIA Portal中配置CM1241串口模块：
1. 设备视图 → 添加CM1241模块
2. 属性 → 常规 → RS485接口
3. 配置参数：
   - 波特率：9600
   - 奇偶校验：无
   - 数据位：8
   - 停止位：1
   - 流控制：无
```

---

## 六、Modbus RTU协议

### 6.1 Modbus协议概述

Modbus是Modicon公司于1979年开发的工业通信协议，已成为工业领域事实上的通用标准。

**Modbus协议类型**：

| 类型 | 传输介质 | 数据格式 | 特点 |
|:-----|:---------|:---------|:-----|
| Modbus RTU | 串口(RS232/485) | 二进制 | 效率高，应用广泛 |
| Modbus ASCII | 串口(RS232/485) | ASCII码 | 可读性好，效率低 |
| Modbus TCP | 以太网 | TCP/IP封装 | 速度快，现代化 |

### 6.2 Modbus RTU帧格式

```
Modbus RTU消息帧：
┌────────┬──────────┬────────────┬─────────┐
│地址域  │ 功能码   │  数据域    │ CRC校验 │
│1字节   │ 1字节    │  N字节     │ 2字节   │
└────────┴──────────┴────────────┴─────────┘
   |          |           |          |
   |          |           |          └── CRC16校验（低字节在前）
   |          |           └── 根据功能码而定
   |          └── 操作类型
   └── 从站地址1-247（0为广播）

帧间隔：≥3.5个字符时间（无数据传输）
```

### 6.3 常用功能码

| 功能码 | 功能名称 | 操作对象 | 操作类型 |
|:------:|:---------|:---------|:---------|
| 01 | 读线圈状态 | 线圈(DO) | 读取 |
| 02 | 读离散输入 | 离散输入(DI) | 读取 |
| 03 | 读保持寄存器 | 保持寄存器(AO) | 读取 |
| 04 | 读输入寄存器 | 输入寄存器(AI) | 读取 |
| 05 | 写单个线圈 | 线圈(DO) | 写入 |
| 06 | 写单个寄存器 | 保持寄存器(AO) | 写入 |
| 15 | 写多个线圈 | 线圈(DO) | 写入 |
| 16 | 写多个寄存器 | 保持寄存器(AO) | 写入 |

### 6.4 Modbus地址映射

```
Modbus寄存器地址规划：
┌──────────────────────────────────────────┐
│ 地址范围        │ 功能码 │ 数据类型     │
├──────────────────────────────────────────┤
│ 00001 - 09999  │  01    │ 线圈(读写)   │
│ 10001 - 19999  │  02    │ 离散输入(只读)│
│ 30001 - 39999  │  04    │ 输入寄存器   │
│ 40001 - 49999  │  03/06 │ 保持寄存器   │
└──────────────────────────────────────────┘

注意：协议地址 = PLC地址 - 1（从0开始）
例：40001寄存器，协议地址为0x0000
```

### 6.5 读保持寄存器示例（功能码03）

**主站请求帧**：
```
读取从站01的保持寄存器40001-40002

请求帧：
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ 01 │ 03 │ 00 │ 00 │ 00 │ 02 │ C4 │ 0B │
└────┴────┴────┴────┴────┴────┴────┴────┘
  |    |    |    |    |    |    └────┘
  |    |    |    |    |    |      CRC校验
  |    |    |    |    └────┘
  |    |    |    |   寄存器数量(2个)
  |    |    └────┘
  |    |   起始地址(0x0000=40001)
  |    └── 功能码03(读保持寄存器)
  └── 从站地址
```

**从站响应帧**：
```
响应帧（假设寄存器值为1234和5678）：

┌────┬────┬────┬────┬────┬────┬────┬────┬────┐
│ 01 │ 03 │ 04 │ 04 │ D2 │ 16 │ 2E │ XX │ XX │
└────┴────┴────┴────┴────┴────┴────┴────┴────┘
  |    |    |    |    |    |    |    └────┘
  |    |    |    |    |    |    |     CRC校验
  |    |    |    |    |    └────┘
  |    |    |    |    |   数据2=0x162E=5678
  |    |    |    └────┘
  |    |    |   数据1=0x04D2=1234
  |    |    └── 字节数(4字节)
  |    └── 功能码03
  └── 从站地址
```

### 6.6 写单个寄存器示例（功能码06）

```
向从站01的寄存器40001写入值1000

请求帧：
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ 01 │ 06 │ 00 │ 00 │ 03 │ E8 │ C9 │ C4 │
└────┴────┴────┴────┴────┴────┴────┴────┘
  |    |    |    |    └────┘    └────┘
  |    |    |    |    数据=0x03E8=1000 CRC
  |    |    └────┘
  |    |   寄存器地址(0x0000)
  |    └── 功能码06
  └── 从站地址

响应帧：（与请求帧相同，表示写入成功）
```

### 6.7 CRC16校验计算

```
CRC16-Modbus计算方法：

多项式：0xA001（0x8005的反转）
初始值：0xFFFF

伪代码：
CRC = 0xFFFF
FOR each byte in message
    CRC = CRC XOR byte
    FOR i = 1 to 8
        IF (CRC AND 0x0001) = 1
            CRC = (CRC >> 1) XOR 0xA001
        ELSE
            CRC = CRC >> 1
        END IF
    NEXT i
NEXT byte
// CRC低字节在前，高字节在后
```

---

## 七、西门子PLC串口通信编程

### 7.1 Modbus RTU主站编程

**使用MB_MASTER指令**：

```
// 读取从站保持寄存器
MB_MASTER_DB(
    REQ      := "Trigger",           // 触发信号
    MB_ADDR  := 1,                   // 从站地址
    MODE     := 0,                   // 0=读,1=写
    DATA_ADDR:= 40001,               // 起始地址
    DATA_LEN := 10,                  // 读取长度
    DATA_PTR := P#DB10.DBX0.0 WORD 10, // 数据存储区
    COM_RST  := "Reset",             // 复位
    DONE     => "ReadDone",          // 完成标志
    BUSY     => "ReadBusy",          // 忙标志
    ERROR    => "ReadError",         // 错误标志
    STATUS   => "ReadStatus"         // 状态码
);
```

### 7.2 Modbus RTU从站编程

**使用MB_SLAVE指令**：

```
// 配置为Modbus从站
MB_SLAVE_DB(
    MB_ADDR      := 1,               // 本站地址
    MB_HOLD_REG  := P#DB20.DBX0.0 WORD 100, // 保持寄存器区
    NDR          => "NewData",       // 新数据接收标志
    DR           => "DataRead",      // 数据被读取标志
    ERROR        => "SlaveError",    // 错误标志
    STATUS       => "SlaveStatus"    // 状态码
);
```

### 7.3 通信状态处理

```
状态机编程模式：
┌─────────────────────────────────────────┐
│              通信状态机                  │
├─────────────────────────────────────────┤
│ State 0: 空闲 ──触发──→ State 1        │
│ State 1: 发送请求 ──完成──→ State 2    │
│ State 2: 等待响应 ──超时──→ State 3    │
│                    ──正常──→ State 4    │
│ State 3: 错误处理 ──重试──→ State 1    │
│                    ──放弃──→ State 0    │
│ State 4: 数据处理 ──完成──→ State 0    │
└─────────────────────────────────────────┘
```

**状态机代码示例**：
```
// 通信状态机
CASE "CommState" OF
    0:  // 空闲状态
        IF "StartComm" THEN
            "CommState" := 1;
            "Timeout_Timer".IN := FALSE;
        END_IF;
        
    1:  // 发送请求
        "MB_REQ" := TRUE;
        IF "MB_DONE" THEN
            "CommState" := 2;
            "Timeout_Timer".IN := TRUE;
        ELSIF "MB_ERROR" THEN
            "CommState" := 3;
        END_IF;
        
    2:  // 等待响应
        "MB_REQ" := FALSE;
        IF "Timeout_Timer".Q THEN
            "CommState" := 3;  // 超时
            "RetryCount" := "RetryCount" + 1;
        ELSIF "ResponseOK" THEN
            "CommState" := 4;
            "RetryCount" := 0;
        END_IF;
        
    3:  // 错误处理
        IF "RetryCount" >= 3 THEN
            "CommState" := 0;  // 放弃
            "CommFault" := TRUE;
        ELSE
            "CommState" := 1;  // 重试
        END_IF;
        
    4:  // 数据处理
        // 处理接收到的数据
        "ProcessData"();
        "CommState" := 0;
        
END_CASE;
```

---

## 八、三菱PLC串口通信

### 8.1 FX系列串口通信

**RS指令（串口发送）**：

```
// RS指令格式
RS  D0  K10  D100  K8  M0

参数说明：
- D0   : 发送数据首地址
- K10  : 发送字节数
- D100 : 接收数据首地址
- K8   : 接收字节数
- M0   : 完成标志
```

### 8.2 通信参数设置

```
FX3U通信参数（D8120）：
┌─────────────────────────────────────┐
│ 位    │ 功能                        │
├───────┼─────────────────────────────┤
│ b0-b3 │ 波特率选择                  │
│ b4    │ 停止位(0=1位,1=2位)         │
│ b5-b6 │ 校验(00=无,01=奇,10=偶)     │
│ b7    │ 数据位(0=7位,1=8位)         │
│ b8-b15│ 协议选择                    │
└───────┴─────────────────────────────┘

波特率设置值：
0: 300    4: 4800    8: 38400
1: 600    5: 9600    9: 57600
2: 1200   6: 19200   A: 115200
3: 2400   7: 38400
```

### 8.3 Modbus通信示例

```
// FX3U Modbus RTU主站读取
// 读取从站地址1，寄存器40001，长度2

MOV  K1    D0       // 从站地址
MOV  H03   D1       // 功能码(03读寄存器)
MOV  K0    D2       // 起始地址
MOV  K2    D3       // 寄存器数量
ADPRW D0 K0 D100    // 执行Modbus通信

// D100-D101 存储读取的数据
```

---

## 九、自由口通信

### 9.1 自由口通信概述

自由口通信允许PLC与非标准协议设备通信，用户可自定义通信协议格式。

**应用场景**：
- 连接条码扫描器
- 连接电子秤
- 连接智能仪表
- 自定义协议设备

### 9.2 西门子自由口编程

**发送数据（Send_P2P）**：
```
Send_P2P_DB(
    REQ    := "SendTrigger",         // 发送触发
    PORT   := "Local~CM_1241",       // 端口
    BUFFER := P#DB1.DBX0.0 BYTE 20,  // 发送缓冲区
    LENGTH := 10,                     // 发送长度
    DONE   => "SendDone",            // 发送完成
    BUSY   => "SendBusy",            // 正在发送
    ERROR  => "SendError"            // 发送错误
);
```

**接收数据（Receive_P2P）**：
```
Receive_P2P_DB(
    EN_R   := TRUE,                  // 使能接收
    PORT   := "Local~CM_1241",       // 端口
    BUFFER := P#DB2.DBX0.0 BYTE 50,  // 接收缓冲区
    NDR    => "NewDataRcvd",         // 新数据标志
    RCVD_LEN => "RcvdLength",        // 接收长度
    ERROR  => "RcvError"             // 接收错误
);
```

### 9.3 协议解析示例

```
// 解析条码数据
// 格式：STX + 数据(20字节) + ETX + BCC
IF "NewDataRcvd" THEN
    // 检查起始符(0x02)
    IF "RcvBuffer"[0] = 16#02 THEN
        // 检查结束符(0x03)
        IF "RcvBuffer"[21] = 16#03 THEN
            // 计算BCC校验
            "CalcBCC" := 0;
            FOR i := 1 TO 21 DO
                "CalcBCC" := "CalcBCC" XOR "RcvBuffer"[i];
            END_FOR;
            
            // 校验正确则提取数据
            IF "CalcBCC" = "RcvBuffer"[22] THEN
                // 复制条码数据
                FOR i := 0 TO 19 DO
                    "BarcodeData"[i] := "RcvBuffer"[i+1];
                END_FOR;
                "BarcodeValid" := TRUE;
            END_IF;
        END_IF;
    END_IF;
END_IF;
```

---

## 十、串口通信故障诊断

### 10.1 常见故障及解决方法

| 故障现象 | 可能原因 | 解决方法 |
|:---------|:---------|:---------|
| 无法通信 | 接线错误 | 检查TXD/RXD交叉 |
| | 参数不匹配 | 核对波特率等参数 |
| | 终端电阻 | RS485两端加120Ω |
| 数据错误 | 干扰 | 使用屏蔽线，单点接地 |
| | 波特率偏差 | 降低波特率 |
| 通信断续 | 接触不良 | 检查接线端子 |
| | 电缆过长 | 缩短距离或加中继 |

### 10.2 诊断工具使用

```
串口调试助手功能：
┌─────────────────────────────────────────┐
│ 1. 配置串口参数（COM口、波特率等）      │
│ 2. 发送测试数据（HEX/ASCII）            │
│ 3. 接收数据显示                         │
│ 4. 分析通信协议                         │
│ 5. 记录通信日志                         │
└─────────────────────────────────────────┘

推荐工具：
- SSCOM（免费）
- Modbus Poll/Slave（Modbus专用）
- 串口猎人
```

### 10.3 波形分析

```
使用示波器分析RS485波形：
                     
    正常波形：           异常波形（反射）：
    ┌──┐  ┌──┐          ┌─╲╱─┐  ┌─╲╱─┐
    │  │  │  │          │    │  │    │
  ──┘  └──┘  └──      ──┘    └──┘    └──
    
检查点：
1. 电平幅度是否正常
2. 波形是否有振铃
3. 上升/下降沿是否正常
```

---

## 十一、实践练习

### 练习1：RS485网络设计

设计一个RS485通信网络，包含1个PLC主站和5个变频器从站。

**要求**：
1. 绘制网络拓扑图
2. 确定通信参数
3. 分配从站地址
4. 计算终端电阻位置

### 练习2：Modbus通信帧分析

分析以下Modbus RTU帧：

```
请求帧：01 03 00 10 00 04 C5 C3
响应帧：01 03 08 00 64 00 C8 01 2C 01 90 XX XX

问题：
1. 这是什么操作？
2. 请求了哪些寄存器？
3. 响应数据的值是多少？
```

### 练习3：PLC串口通信程序

编写一个西门子S7-1200程序：
- 通过RS485读取温度变送器数据
- 变送器地址：1
- 温度寄存器：40001
- 每2秒读取一次
- 显示温度值（0.1℃分辨率）

---

## 本节小结

1. **RS232/RS485/RS422**是工业常用的串口通信标准
2. **RS232**适合短距离点对点通信
3. **RS485**适合长距离多点通信，工业应用最广泛
4. **Modbus RTU**是工业领域最通用的串口协议
5. 通信参数配置必须**双方一致**
6. RS485布线要注意**终端电阻**和**屏蔽接地**

---

## 思考题

1. 为什么RS485比RS232传输距离更远？
2. Modbus RTU功能码03和04有什么区别？
3. RS485网络中为什么要加终端电阻？
4. 如何提高串口通信的可靠性？
5. 自由口通信与Modbus通信各有什么优缺点？

---

> **下一节预告**：6.3 以太网通信 - 学习工业以太网和Modbus TCP协议
